/* Дан файл data.txt с текстом. Текст состоит из слов разделенных пробелами. Слова состоят из строчных латинских символов.
Текст заканчивается словом stopword. Посмотреть содержимое файла можно тут.
Реализуйте алгоритм, который по введённому слову target предскажет следующее слово. А именно, выведет в терминал три
возможных варианта следующего за target слова (без повторов) по следующим правилам:
Если есть слово X, которое, в тексте, встречалось после слова target чаще остальных, то выводим его.
Если слова X и Y встречались одинаковое количество раз после слова target, то выводим то, которое лексикографически меньше.
Например, для hi и by, нужно вывести by.
Если все различные слова, которые встречались после target уже выведены (даже если их меньше 3х), то закончить вывод;
Если слова target в тексте нет, выведите один символ минус -.
Например:
Текст: текст состоит из слов разделенных пробелами слова состоят из строчных латинских символов stopword
Таргет: слов
Вывод: разделенных 
Таргет: из
Вывод: слов строчных
Таргет: бэтмен
Вывод: -
Как получить данные из файла

Формат ввода
Файл data.txt, расположен в том же каталоге, что и программа. На вход программе подаётся одно слово target состоящее из строчных латинских символов.
Формат вывода
Символ минус - или до 3х слов разделённых пробелами.

Пример 1
Ввод	Вывод
your
hair grandmother shoulders
Пример 2
Ввод	Вывод
already
fifteen
*/

#include <iostream>
#include <fstream>
#include <map>
#include <vector>
#include <algorithm>

int main() {
    std::ifstream f("data.txt"); //приложенный файлик
    std::map<std::string, int> m; //словарь <слова - их количество>
    std::string target, w; //слово, ключевое слово

    //считываем данные
    std::cin >> target;
    if (f.is_open()) {
        bool t = false; //предыдущее слово target?
        for (f >> w; !f.eof(); f >> w) {
            if (w == "stopword")
                break;
            else if (t == true) {
                t = false;
                m[w]++;
            } else if (w == target)
                t = true;
        }
        f.close();
    }

    if (!m.empty()) {
        //сортировка с лямбдой по условиям
        std::vector<std::pair<std::string, int>> s(m.begin(), m.end());
        std::sort(s.begin(), s.end(), [](const auto& a, const auto& b) {
            return a.second > b.second || (a.second == b.second && a.first < b.first);
        });
        //вывод результата
        for (size_t i = 0; i < std::min(s.size(), static_cast<size_t>(3)); i++) {
            std::cout << s[i].first;
            if (i != std::min(s.size(), static_cast<size_t>(3)) - 1)
                std::cout << " ";
        }
    } else
        //отсутствие результата
        std::cout << "-";

    return 0;
}